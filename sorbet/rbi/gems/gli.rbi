# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/gli/all/gli.rbi
#
# gli-2.20.1

module GLI
  def self.included(klass); end
  def self.run(*args); end
  include GLI::App
end
class GLI::CommandFinder
  def commands_with_aliases; end
  def commands_with_aliases=(arg0); end
  def expand_with_aliases(commands); end
  def find_command(name); end
  def find_command_by_partial_name(commands_with_aliases, command_to_match); end
  def initialize(commands, options = nil); end
  def options; end
  def options=(arg0); end
end
class GLI::GLIOptionBlockParser
  def do_parse(args); end
  def initialize(option_parser_factory, exception_klass_or_block); end
  def parse!(args); end
end
class GLI::CommandOptionBlockParser < GLI::GLIOptionBlockParser
  def break_on_non_option?; end
  def command=(command_being_parsed); end
  def do_parse(args); end
end
class GLI::LegacyCommandOptionBlockParser < GLI::CommandOptionBlockParser
  def break_on_non_option?; end
end
class GLI::OptionParserFactory
  def initialize(flags, switches, accepts); end
  def option_parser; end
  def options_hash; end
  def options_hash_with_defaults_set!; end
  def self.add_help_switches_to_command(option_parser, command); end
  def self.for_command(command, accepts); end
  def self.setup_accepts(opts, accepts); end
  def self.setup_options(opts, tokens, options); end
  def set_defaults(options_by_name, options_hash); end
end
class GLI::OptionParsingResult
  def arguments; end
  def arguments=(arg0); end
  def command; end
  def command=(arg0); end
  def command_options; end
  def command_options=(arg0); end
  def convert_to_openstruct!; end
  def global_options; end
  def global_options=(arg0); end
  def to_a; end
end
class GLI::GLIOptionParser
  def initialize(commands, flags, switches, accepts, options = nil); end
  def options; end
  def options=(arg0); end
  def parse_options(args); end
end
class GLI::GLIOptionParser::GlobalOptionParser
  def initialize(option_parser_factory, command_finder, flags); end
  def parse!(parsing_result); end
  def verify_arguments!(arguments, command); end
  def verify_required_options!(flags, command, options); end
end
class GLI::GLIOptionParser::NormalCommandOptionParser < GLI::GLIOptionParser::GlobalOptionParser
  def error_handler; end
  def initialize(accepts); end
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end
end
class GLI::GLIOptionParser::LegacyCommandOptionParser < GLI::GLIOptionParser::NormalCommandOptionParser
  def find_subcommand(command, arguments, autocomplete); end
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end
end
module GLI::AppSupport
  def accepts; end
  def add_help_switch_if_needed(target); end
  def argument_handling_strategy; end
  def around_blocks; end
  def autocomplete; end
  def call_command(parsing_result); end
  def clear_nexts; end
  def commands; end
  def commands_declaration_order; end
  def config_file_name; end
  def context_description; end
  def error_device=(e); end
  def error_message(ex); end
  def exe_name; end
  def flags; end
  def get_default_command; end
  def handle_exception(ex, command); end
  def help_sort_type; end
  def help_text_wrap_type; end
  def no_message_given?(ex); end
  def output_error_message(ex); end
  def override_command_defaults(command_list, config); end
  def override_default(tokens, config); end
  def override_defaults_based_on_config(config); end
  def parse_config; end
  def post_block; end
  def pre_block; end
  def proceed?(parsing_result); end
  def regular_error_handling?(ex); end
  def reset; end
  def run(args); end
  def self.included(klass); end
  def stderr; end
  def subcommand_option_handling_strategy; end
  def switches; end
  def synopsis_format_type; end
  def version_string; end
end
module GLI::DSL
  def arg(name, options = nil); end
  def arg_name(name, options = nil); end
  def c(*names); end
  def clear_nexts; end
  def command(*names); end
  def d(description); end
  def default_value(val); end
  def desc(description); end
  def extract_options(names); end
  def f(*names); end
  def flag(*names); end
  def flags_declaration_order; end
  def long_desc(long_desc); end
  def s(*names); end
  def switch(*names); end
  def switches_declaration_order; end
  def verify_unused(names); end
  def verify_unused_in_option(name, option_like, type); end
end
module GLI::App
  def accept(object, &block); end
  def arguments(handling_strategy); end
  def around(&a_proc); end
  def autocomplete_commands(boolean); end
  def commands_from(path); end
  def config_file(filename); end
  def default_command(command); end
  def exit_now!(message, exit_code = nil); end
  def help_now!(message = nil); end
  def hide_commands_without_desc(hide = nil); end
  def load_commands(path); end
  def on_error(&a_proc); end
  def post(&a_proc); end
  def pre(&a_proc); end
  def preserve_argv(preserve = nil); end
  def program_desc(description = nil); end
  def program_long_desc(description = nil); end
  def program_name(override = nil); end
  def skips_around; end
  def skips_post; end
  def skips_pre; end
  def sort_help(sort_type); end
  def subcommand_option_handling(handling_strategy); end
  def synopsis_format(format); end
  def use_openstruct(use_openstruct); end
  def version(version); end
  def wrap_help_text(wrap_type); end
  include GLI::AppSupport
  include GLI::DSL
end
module GLI::CommandSupport
  def am_subcommand?; end
  def arg_name(d, options = nil); end
  def arguments; end
  def arguments_description; end
  def arguments_options; end
  def commands; end
  def commands_declaration_order; end
  def context_description; end
  def default_description; end
  def default_value(d); end
  def desc(d); end
  def examples; end
  def execute(global_options, options, arguments); end
  def flag(*names); end
  def flags; end
  def generate_error_action(arguments); end
  def get_action(arguments); end
  def get_default_command; end
  def has_action?; end
  def have_subcommands?; end
  def long_desc(d); end
  def names; end
  def nodoc; end
  def parent; end
  def parent=(arg0); end
  def send_declarations_to_parent?; end
  def skips_around; end
  def skips_post; end
  def skips_pre; end
  def switch(*names); end
  def switches; end
  def topmost_ancestor; end
end
class GLI::CommandLineToken
  def <=>(other); end
  def aliases; end
  def all_forms(joiner = nil); end
  def all_forms_a; end
  def description; end
  def initialize(names, description, long_description = nil); end
  def long_description; end
  def name; end
  def names_and_aliases; end
  def negatable?; end
  def parse_names(names); end
end
class GLI::Command < GLI::CommandLineToken
  def action(&block); end
  def default_command(command_name); end
  def default_desc(desc); end
  def example(example_invocation, options = nil); end
  def has_option?(option); end
  def initialize(options); end
  def name_for_help; end
  def self.name_as_string(name, negatable = nil); end
  include GLI::CommandSupport
  include GLI::DSL
end
class GLI::Command::ParentKey
  def to_sym; end
end
class GLI::CommandLineOption < GLI::CommandLineToken
  def associated_command; end
  def associated_command=(arg0); end
  def default_value; end
  def default_value=(arg0); end
  def initialize(names, options = nil); end
  def self.name_as_string(name, negatable = nil); end
end
module GLI::StandardException
  def exit_code; end
end
class GLI::RequestHelp < StandardError
  def command_in_context; end
  def exit_code; end
  def initialize(command_in_context); end
  include GLI::StandardException
end
class GLI::BadCommandLine < StandardError
  def exit_code; end
  include GLI::StandardException
end
class GLI::PreconditionFailed < StandardError
  def exit_code; end
  include GLI::StandardException
end
class GLI::UnknownCommand < GLI::BadCommandLine
end
class GLI::AmbiguousCommand < GLI::BadCommandLine
end
class GLI::UnknownGlobalArgument < GLI::BadCommandLine
end
class GLI::CommandException < GLI::BadCommandLine
  def command_in_context; end
  def exit_code; end
  def initialize(message, command_in_context, exit_code = nil); end
end
class GLI::MissingRequiredArgumentsException < GLI::BadCommandLine
  def command_in_context; end
  def initialize(message, command); end
end
class GLI::UnknownCommandArgument < GLI::CommandException
end
class GLI::CustomExit < StandardError
  def exit_code; end
  def initialize(message, exit_code); end
  include GLI::StandardException
end
class GLI::Flag < GLI::CommandLineOption
  def all_forms(joiner = nil); end
  def argument_name; end
  def arguments_for_option_parser; end
  def default_value; end
  def initialize(names, options); end
  def multiple?; end
  def must_match; end
  def required?; end
  def safe_default_value; end
  def type; end
end
class GLI::Options < OpenStruct
  def [](k); end
  def []=(k, v); end
  def map(&block); end
end
class GLI::Switch < GLI::CommandLineOption
  def arguments_for_option_parser; end
  def default_value; end
  def default_value=(arg0); end
  def initialize(names, options = nil); end
  def negatable; end
  def negatable?; end
  def required?; end
end
class GLI::Argument
  def initialize(name, options = nil); end
  def multiple?; end
  def name; end
  def optional?; end
  def options; end
end
class GLI::Terminal
  def command_exists?(command); end
  def make_unsafe!; end
  def self.command_exists?(command); end
  def self.default_size; end
  def self.default_size=(size); end
  def self.instance; end
  def self.jruby?; end
  def self.run_command(command); end
  def self.solaris?; end
  def size; end
end
module GLI::Commands
end
module GLI::Commands::HelpModules
end
class GLI::Commands::HelpModules::ListFormatter
  def initialize(list, wrapper_class = nil); end
  def output(output_device); end
end
class GLI::Commands::HelpModules::TextWrapper
  def initialize(width, indent); end
  def wrap(text); end
end
class GLI::Commands::HelpModules::OneLineWrapper
  def initialize(width, indent); end
  def wrap(text); end
end
class GLI::Commands::HelpModules::VerbatimWrapper
  def initialize(width, indent); end
  def wrap(text); end
end
class GLI::Commands::HelpModules::TTYOnlyWrapper
  def initialize(width, indent); end
  def wrap(text); end
end
class GLI::Commands::HelpModules::OptionsFormatter
  def description_with_default(option); end
  def format; end
  def initialize(flags_and_switches, sorter, wrapper_class); end
  def option_names_for_help_string(option, arg_name = nil); end
end
class GLI::Commands::HelpModules::GlobalHelpFormat
  def format; end
  def global_flags_and_switches; end
  def initialize(app, sorter, wrapper_class); end
  def usage_string; end
end
class GLI::Commands::HelpModules::CommandHelpFormat
  def flags_and_switches(command, app); end
  def format; end
  def format_examples(command); end
  def format_subcommands(command); end
  def initialize(command, app, sorter, synopsis_formatter_class, wrapper_class = nil); end
end
class GLI::Commands::HelpModules::HelpCompletionFormat
  def format; end
  def initialize(app, command_finder, args); end
end
class GLI::Commands::HelpModules::CommandFinder
  def find_command(name); end
  def find_command_from_base(command_name, base); end
  def initialize(app, arguments, error); end
  def last_found_command; end
  def last_unknown_command; end
  def squelch_stderr=(arg0); end
  def unknown_command?(command, name, error); end
end
class GLI::Commands::HelpModules::ArgNameFormatter
  def format(arguments_description, arguments_options, arguments); end
  def format_argname(arguments_description, arguments_options); end
  def format_arguments(arguments); end
end
class GLI::Commands::HelpModules::FullSynopsisFormatter
  def basic_usage(command); end
  def command_with_subcommand_usage(command, sub, is_default_command); end
  def global_flags_and_switches; end
  def initialize(app, flags_and_switches); end
  def path_to_command(command); end
  def sorted_synopses(command); end
  def sub_options_doc(sub_options); end
  def synopses_for_command(command); end
end
class GLI::Commands::HelpModules::CompactSynopsisFormatter < GLI::Commands::HelpModules::FullSynopsisFormatter
  def sub_options_doc(sub_options); end
end
class GLI::Commands::HelpModules::TerminalSynopsisFormatter
  def initialize(app, flags_and_switches); end
  def synopses_for_command(command); end
end
class GLI::Commands::Help < GLI::Command
  def initialize(app, output = nil, error = nil); end
  def self.skips_around=(skips_around); end
  def self.skips_post=(skips_post); end
  def self.skips_pre=(skips_pre); end
  def show_help(global_options, options, arguments, out, error); end
  def skips_around; end
  def skips_post; end
  def skips_pre; end
end
class GLI::Commands::CompoundCommand < GLI::Command
  def check_for_unknown_commands!(base, command_names); end
  def execute(global_options, options, arguments); end
  def initialize(base, configuration, options = nil); end
  def self.find_command(base, name); end
end
class GLI::InitConfig < GLI::Command
  def config_for_command(commands, command_name); end
  def create_config(global_options, options, arguments); end
  def initialize(config_file_name, commands, flags, switches); end
end
class GLI::Commands::RdocDocumentListener
  def add_dashes(name); end
  def beginning; end
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end
  def commands; end
  def default_command(name); end
  def end_command(name); end
  def end_commands; end
  def end_options; end
  def ending; end
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end
  def initialize(global_options, options, arguments, app); end
  def options; end
  def program_desc(desc); end
  def program_long_desc(desc); end
  def switch(name, aliases, desc, long_desc, negatable); end
  def version(version); end
end
class GLI::Commands::Doc < GLI::Command
  def any_commands?(command); end
  def any_options?(context); end
  def by_name; end
  def call_command_method_being_backwards_compatible(document_listener, command); end
  def command_flags(command); end
  def command_switches(command); end
  def document(document_listener); end
  def document_commands(document_listener, context); end
  def document_flags_and_switches(document_listener, flags, switches); end
  def format_class(format_name); end
  def initialize(app); end
  def nodoc; end
end
class GLI::Commands::Doc::DocumentListener
  def abstract!; end
  def beginning; end
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end
  def commands; end
  def default_command(name); end
  def end_command(name); end
  def end_commands; end
  def end_options; end
  def ending; end
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end
  def initialize(global_options, options, arguments, app); end
  def options; end
  def program_desc(desc); end
  def program_long_desc(desc); end
  def switch(name, aliases, desc, long_desc, negatable); end
  def version(version); end
end
