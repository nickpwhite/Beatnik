# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/semantic_range/all/semantic_range.rbi
#
# semantic_range-3.0.0

module SemanticRange
  def self.clean(version, loose: nil); end
  def self.cmp(a, op, b, loose: nil); end
  def self.compare(a, b, loose: nil); end
  def self.compare_loose(a, b); end
  def self.diff(a, b); end
  def self.eq(a, b, loose: nil); end
  def self.eq?(a, b, loose: nil); end
  def self.filter(versions, range, loose: nil, platform: nil); end
  def self.gt(a, b, loose: nil); end
  def self.gt?(a, b, loose: nil); end
  def self.gte(a, b, loose: nil); end
  def self.gte?(a, b, loose: nil); end
  def self.gtr(version, range, loose: nil, platform: nil); end
  def self.gtr?(version, range, loose: nil, platform: nil); end
  def self.increment!(version, release, identifier, loose: nil); end
  def self.lt(a, b, loose: nil); end
  def self.lt?(a, b, loose: nil); end
  def self.lte(a, b, loose: nil); end
  def self.lte?(a, b, loose: nil); end
  def self.ltr(version, range, loose: nil, platform: nil); end
  def self.ltr?(version, range, loose: nil, platform: nil); end
  def self.max_satisfying(versions, range, loose: nil, platform: nil); end
  def self.neq(a, b, loose: nil); end
  def self.neq?(a, b, loose: nil); end
  def self.outside(version, range, hilo, loose: nil, platform: nil); end
  def self.outside?(version, range, hilo, loose: nil, platform: nil); end
  def self.parse(version, loose: nil); end
  def self.rcompare(a, b, loose: nil); end
  def self.rsort(list, loose: nil); end
  def self.satisfies(version, range, loose: nil, platform: nil); end
  def self.satisfies?(version, range, loose: nil, platform: nil); end
  def self.sort(list, loose: nil); end
  def self.to_comparators(range, loose: nil, platform: nil); end
  def self.valid(version, loose: nil); end
  def self.valid_range(range, loose: nil, platform: nil); end
end
class SemanticRange::Version
  def compare(other); end
  def compare_main(other); end
  def compare_pre(other); end
  def format; end
  def increment!(release, identifier); end
  def initialize(version, loose: nil); end
  def major; end
  def minor; end
  def patch; end
  def prerelease; end
  def raw; end
  def self.compare_identifiers(a, b); end
  def to_s; end
  def truthy(val); end
  def version; end
end
class SemanticRange::PreRelease
  def <=>(other); end
  def clear!; end
  def convert(str); end
  def empty?; end
  def increment!(identifier = nil); end
  def initialize(input); end
  def last_number_index; end
  def length; end
  def parse(str); end
  def parts; end
  def to_s; end
  def zero!; end
end
class SemanticRange::Range
  def format; end
  def hyphen_replace(match); end
  def initialize(range, loose: nil, platform: nil); end
  def intersects(range, loose: nil, platform: nil); end
  def isX(id); end
  def loose; end
  def parse_comparator(comp, loose); end
  def parse_range(range); end
  def platform; end
  def range; end
  def raw; end
  def replace_caret(comp, loose); end
  def replace_carets(comp, loose); end
  def replace_stars(comp, loose); end
  def replace_tilde(comp, loose); end
  def replace_tildes(comp, loose); end
  def replace_x_range(comp, loose); end
  def replace_x_ranges(comp, loose); end
  def set; end
  def test(version); end
  def test_set(set, version); end
end
class SemanticRange::Comparator
  def initialize(comp, loose); end
  def intersects(comp, loose: nil, platform: nil); end
  def intersects?(comp, loose: nil, platform: nil); end
  def operator; end
  def parse(comp); end
  def satisfies_range(range, loose: nil, platform: nil); end
  def satisfies_range?(range, loose: nil, platform: nil); end
  def semver; end
  def test(version); end
  def to_s; end
  def value; end
end
class SemanticRange::InvalidIncrement < StandardError
end
class SemanticRange::InvalidVersion < StandardError
end
class SemanticRange::InvalidComparator < StandardError
end
class SemanticRange::InvalidRange < StandardError
end
