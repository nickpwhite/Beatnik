# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/watir/all/watir.rbi
#
# watir-6.19.1

module Watir
  def self.always_locate=(arg0); end
  def self.always_locate?; end
  def self.always_locate_message; end
  def self.default_timeout; end
  def self.default_timeout=(arg0); end
  def self.element_class_for(tag_name); end
  def self.logger; end
  def self.prefer_css=(arg0); end
  def self.prefer_css?; end
  def self.prefer_css_message; end
  def self.relaxed_locate=(arg0); end
  def self.relaxed_locate?; end
  def self.tag_to_class; end
end
module Watir::Scrolling
  def scroll; end
end
class Watir::Scroll
  def browser_scroll(param); end
  def by(left, top); end
  def element_scroll(param); end
  def initialize(object); end
  def to(param = nil); end
end
class Watir::BaseDecorator
  def initialize(element, timeout, message = nil); end
  def method_missing(method, *args, &block); end
  def respond_to_missing?(*args); end
end
class Watir::WhenPresentDecorator < Watir::BaseDecorator
  def present?; end
  def wait_until; end
end
class Watir::WhenEnabledDecorator < Watir::BaseDecorator
  def wait_until; end
end
module Watir::EventuallyPresent
  def when_enabled(timeout = nil); end
  def when_present(timeout = nil); end
end
module Watir::Wait
  def self.message_for(timeout, object, message); end
  def self.run_with_timer(timeout, interval); end
  def self.timer; end
  def self.timer=(arg0); end
  def self.until(depr_timeout = nil, depr_message = nil, timeout: nil, message: nil, interval: nil, object: nil); end
  def self.while(depr_timeout = nil, depr_message = nil, timeout: nil, message: nil, interval: nil, object: nil); end
end
class Watir::Wait::Timer
  def current_time; end
  def initialize(timeout: nil); end
  def locked?; end
  def remaining_time; end
  def reset!; end
  def wait(timeout, &block); end
end
class Watir::Wait::TimeoutError < StandardError
end
module Watir::Waitable
  def create_proc(opt); end
  def match_attributes(opt); end
  def wait_until(depr_timeout = nil, depr_message = nil, timeout: nil, message: nil, interval: nil, **opt, &blk); end
  def wait_until_present(depr_timeout = nil, timeout: nil, interval: nil, message: nil); end
  def wait_while(depr_timeout = nil, depr_message = nil, timeout: nil, message: nil, interval: nil, **opt, &blk); end
  def wait_while_present(depr_timeout = nil, timeout: nil, interval: nil, message: nil); end
end
module Watir::Exception
end
class Watir::Exception::Error < StandardError
end
class Watir::Exception::UnknownObjectException < Watir::Exception::Error
end
class Watir::Exception::ObjectDisabledException < Watir::Exception::Error
end
class Watir::Exception::ObjectReadOnlyException < Watir::Exception::Error
end
class Watir::Exception::NoValueFoundException < Watir::Exception::Error
end
class Watir::Exception::NoMatchingWindowFoundException < Watir::Exception::Error
end
class Watir::Exception::UnknownFrameException < Watir::Exception::Error
end
class Watir::Exception::LocatorException < Watir::Exception::Error
end
class Watir::Window
  def ==(other); end
  def assert_exists; end
  def browser; end
  def close; end
  def current?; end
  def current_window; end
  def eql?(other); end
  def exist?; end
  def exists?; end
  def handle; end
  def hash; end
  def initialize(browser, selector = nil); end
  def inspect; end
  def locate; end
  def matches?(handle); end
  def maximize; end
  def move_to(x_coord, y_coord); end
  def position; end
  def present?; end
  def resize_to(width, height); end
  def selector_string; end
  def size; end
  def title; end
  def url; end
  def use(&blk); end
  def wait_for_exists; end
  include Watir::EventuallyPresent
  include Watir::Exception
  include Watir::Waitable
end
class Watir::WindowCollection
  def ==(other); end
  def [](value); end
  def each(&blk); end
  def empty?(*arg0); end
  def eql?(other); end
  def first; end
  def initialize(browser, selector = nil); end
  def last; end
  def length(*arg0); end
  def matches?(handle); end
  def reset!; end
  def size(*arg0); end
  def to_a; end
  def window_list; end
  include Enumerable
  include Watir::Waitable
end
module Watir::HasWindow
  def original_window; end
  def switch_window; end
  def window(*args, &blk); end
  def windows(*args); end
end
module Watir::Adjacent
  def child(opt = nil); end
  def children(opt = nil); end
  def following_sibling(opt = nil); end
  def following_siblings(opt = nil); end
  def next_sibling(opt = nil); end
  def next_siblings(opt = nil); end
  def parent(opt = nil); end
  def preceding_sibling(opt = nil); end
  def preceding_siblings(opt = nil); end
  def previous_sibling(opt = nil); end
  def previous_siblings(opt = nil); end
  def siblings(opt = nil); end
  def xpath_adjacent(opt = nil); end
end
module Watir::JSExecution
  def execute_script(script, *args, function_name: nil); end
  def fire_event(event_name); end
  def flash(preset = nil, color: nil, flashes: nil, delay: nil); end
  def focus; end
  def html; end
  def inner_html; end
  def inner_text; end
  def outer_html; end
  def select_text(str); end
  def selected_text; end
  def text_content; end
end
class Watir::Alert
  def assert_exists; end
  def close; end
  def exist?; end
  def exists?; end
  def initialize(browser); end
  def ok; end
  def present?; end
  def selector_string; end
  def set(value); end
  def text; end
  def wait_for_exists; end
  include Watir::EventuallyPresent
  include Watir::Exception
  include Watir::Waitable
end
module Watir::JSSnippets
  def execute_js(function_name, *arguments); end
end
module Watir::Container
  def a(*args); end
  def abbr(*args); end
  def abbrs(*args); end
  def address(*args); end
  def addresses(*args); end
  def area(*args); end
  def areas(*args); end
  def article(*args); end
  def articles(*args); end
  def as(*args); end
  def aside(*args); end
  def asides(*args); end
  def audio(*args); end
  def audios(*args); end
  def b(*args); end
  def base(*args); end
  def bases(*args); end
  def bdi(*args); end
  def bdis(*args); end
  def bdo(*args); end
  def bdos(*args); end
  def blockquote(*args); end
  def blockquotes(*args); end
  def body(*args); end
  def bodys(*args); end
  def br(*args); end
  def brs(*args); end
  def bs(*args); end
  def button(*args); end
  def buttons(*args); end
  def canvas(*args); end
  def canvases(*args); end
  def caption(*args); end
  def captions(*args); end
  def checkbox(*args); end
  def checkboxes(*args); end
  def circle(*args); end
  def circles(*args); end
  def cite(*args); end
  def cites(*args); end
  def code(*args); end
  def codes(*args); end
  def col(*args); end
  def colgroup(*args); end
  def colgroups(*args); end
  def cols(*args); end
  def data(*args); end
  def datalist(*args); end
  def datalists(*args); end
  def datas(*args); end
  def date_field(*args); end
  def date_fields(*args); end
  def date_time_field(*args); end
  def date_time_fields(*args); end
  def dd(*args); end
  def dds(*args); end
  def defs(*args); end
  def defss(*args); end
  def del(*args); end
  def dels(*args); end
  def desc(*args); end
  def descs(*args); end
  def details(*args); end
  def detailses(*args); end
  def dfn(*args); end
  def dfns(*args); end
  def dialog(*args); end
  def dialogs(*args); end
  def div(*args); end
  def divs(*args); end
  def dl(*args); end
  def dls(*args); end
  def dt(*args); end
  def dts(*args); end
  def element(*args); end
  def elements(*args); end
  def ellipse(*args); end
  def ellipses(*args); end
  def em(*args); end
  def embed(*args); end
  def embeds(*args); end
  def ems(*args); end
  def extract_selector(selector); end
  def field_set(*args); end
  def field_sets(*args); end
  def fieldset(*args); end
  def fieldsets(*args); end
  def figcaption(*args); end
  def figcaptions(*args); end
  def figure(*args); end
  def figures(*args); end
  def file_field(*args); end
  def file_fields(*args); end
  def font(*args); end
  def fonts(*args); end
  def footer(*args); end
  def footers(*args); end
  def foreign_object(*args); end
  def foreign_objects(*args); end
  def form(*args); end
  def forms(*args); end
  def frame(*args); end
  def frames(*args); end
  def frameset(*args); end
  def framesets(*args); end
  def g(*args); end
  def gs(*args); end
  def h1(*args); end
  def h1s(*args); end
  def h2(*args); end
  def h2s(*args); end
  def h3(*args); end
  def h3s(*args); end
  def h4(*args); end
  def h4s(*args); end
  def h5(*args); end
  def h5s(*args); end
  def h6(*args); end
  def h6s(*args); end
  def head(*args); end
  def header(*args); end
  def headers(*args); end
  def heads(*args); end
  def hidden(*args); end
  def hiddens(*args); end
  def hr(*args); end
  def hrs(*args); end
  def html(*args); end
  def htmls(*args); end
  def i(*args); end
  def iframe(*args); end
  def iframes(*args); end
  def image(*args); end
  def images(*args); end
  def img(*args); end
  def imgs(*args); end
  def input(*args); end
  def inputs(*args); end
  def ins(*args); end
  def inses(*args); end
  def is(*args); end
  def kbd(*args); end
  def kbds(*args); end
  def label(*args); end
  def labels(*args); end
  def legend(*args); end
  def legends(*args); end
  def li(*args); end
  def line(*args); end
  def linear_gradient(*args); end
  def linear_gradients(*args); end
  def lines(*args); end
  def link(*args); end
  def links(*args); end
  def lis(*args); end
  def main(*args); end
  def mains(*args); end
  def map(*args); end
  def maps(*args); end
  def mark(*args); end
  def marker(*args); end
  def markers(*args); end
  def marks(*args); end
  def meta(*args); end
  def metadata(*args); end
  def metadatas(*args); end
  def metas(*args); end
  def meter(*args); end
  def meters(*args); end
  def nav(*args); end
  def navs(*args); end
  def noscript(*args); end
  def noscripts(*args); end
  def object(*args); end
  def objects(*args); end
  def ol(*args); end
  def ols(*args); end
  def optgroup(*args); end
  def optgroups(*args); end
  def option(*args); end
  def options(*args); end
  def output(*args); end
  def outputs(*args); end
  def p(*args); end
  def param(*args); end
  def params(*args); end
  def path(*args); end
  def paths(*args); end
  def pattern(*args); end
  def patterns(*args); end
  def picture(*args); end
  def pictures(*args); end
  def polygon(*args); end
  def polygons(*args); end
  def polyline(*args); end
  def polylines(*args); end
  def pre(*args); end
  def pres(*args); end
  def progress(*args); end
  def progresses(*args); end
  def ps(*args); end
  def q(*args); end
  def qs(*args); end
  def radial_gradient(*args); end
  def radial_gradients(*args); end
  def radio(*args); end
  def radio_set(*args); end
  def radios(*args); end
  def rb(*args); end
  def rbs(*args); end
  def rect(*args); end
  def rects(*args); end
  def rp(*args); end
  def rps(*args); end
  def rt(*args); end
  def rtc(*args); end
  def rtcs(*args); end
  def rts(*args); end
  def rubies(*args); end
  def ruby(*args); end
  def s(*args); end
  def samp(*args); end
  def samps(*args); end
  def script(*args); end
  def scripts(*args); end
  def section(*args); end
  def sections(*args); end
  def select(*args); end
  def select_list(*args); end
  def select_lists(*args); end
  def selects(*args); end
  def small(*args); end
  def smalls(*args); end
  def source(*args); end
  def sources(*args); end
  def span(*args); end
  def spans(*args); end
  def ss(*args); end
  def stop(*args); end
  def stops(*args); end
  def strong(*args); end
  def strongs(*args); end
  def style(*args); end
  def styles(*args); end
  def sub(*args); end
  def subs(*args); end
  def summaries(*args); end
  def summary(*args); end
  def sup(*args); end
  def sups(*args); end
  def svg(*args); end
  def svgs(*args); end
  def switch(*args); end
  def switches(*args); end
  def symbol(*args); end
  def symbols(*args); end
  def table(*args); end
  def tables(*args); end
  def tbody(*args); end
  def tbodys(*args); end
  def td(*args); end
  def tds(*args); end
  def template(*args); end
  def templates(*args); end
  def text_field(*args); end
  def text_fields(*args); end
  def text_path(*args); end
  def text_paths(*args); end
  def textarea(*args); end
  def textareas(*args); end
  def tfoot(*args); end
  def tfoots(*args); end
  def th(*args); end
  def thead(*args); end
  def theads(*args); end
  def ths(*args); end
  def time(*args); end
  def times(*args); end
  def title(*args); end
  def titles(*args); end
  def tr(*args); end
  def track(*args); end
  def tracks(*args); end
  def trs(*args); end
  def tspan(*args); end
  def tspans(*args); end
  def u(*args); end
  def ul(*args); end
  def uls(*args); end
  def us(*args); end
  def use(*args); end
  def uses(*args); end
  def var(*args); end
  def vars(*args); end
  def video(*args); end
  def videos(*args); end
  def view(*args); end
  def views(*args); end
  def wbr(*args); end
  def wbrs(*args); end
  include Watir::JSSnippets
end
class Watir::Cookies
  def [](name); end
  def add(name, value, opts = nil); end
  def clear; end
  def delete(name); end
  def initialize(control); end
  def load(file = nil); end
  def save(file = nil); end
  def to_a; end
end
class Watir::HttpClient < Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: nil, read_timeout: nil, client_timeout: nil); end
  def request(verb, url, headers, payload, redirects = nil); end
end
class Watir::Capabilities
  def deprecate_args; end
  def deprecate_client_timeout(http_client); end
  def deprecate_desired_capabilities; end
  def deprecate_open_timeout(http_client); end
  def deprecate_options_capabilities; end
  def deprecate_read_timeout(http_client); end
  def deprecate_remote(browser); end
  def deprecate_service_keywords; end
  def deprecate_switches; end
  def deprecate_url_service; end
  def infer_browser; end
  def initialize(browser = nil, options = nil); end
  def options; end
  def process_args; end
  def process_arguments; end
  def process_browser_options; end
  def process_capabilities; end
  def process_chrome_options(browser_options); end
  def process_firefox_options(browser_options); end
  def process_http_client; end
  def process_http_client_timeouts(http_client); end
  def process_ie_options(browser_options); end
  def process_safari_options(browser_options); end
  def process_service(service); end
  def process_w3c_capabilities(opts); end
  def to_args; end
end
module Watir::Navigation
  def back; end
  def forward; end
  def goto(uri); end
  def refresh; end
end
class Watir::Browser
  def after_hooks; end
  def alert; end
  def browser; end
  def close; end
  def cookies; end
  def default_context=(arg0); end
  def driver; end
  def ensure_context; end
  def execute_script(script, *args, function_name: nil); end
  def exist?; end
  def exists?; end
  def html; end
  def initialize(browser = nil, *args); end
  def inspect; end
  def locate; end
  def locator_namespace; end
  def locator_namespace=(arg0); end
  def name; end
  def original_window=(arg0); end
  def quit; end
  def ready_state; end
  def screenshot; end
  def selector_string; end
  def self.start(url, browser = nil, *args); end
  def send_keys(*args); end
  def status; end
  def text; end
  def timer; end
  def timer=(arg0); end
  def title; end
  def url; end
  def wait(timeout = nil); end
  def wd; end
  def wrap_element(scope, element); end
  def wrap_elements_in(scope, obj); end
  include Watir::Container
  include Watir::Exception
  include Watir::HasWindow
  include Watir::Navigation
  include Watir::Scrolling
  include Watir::Waitable
end
class Watir::Screenshot
  def base64; end
  def initialize(browser); end
  def png; end
  def save(path); end
end
class Watir::AfterHooks
  def <<(after_hook = nil, &block); end
  def [](index); end
  def add(after_hook = nil, &block); end
  def delete(after_hook); end
  def each(&blk); end
  def initialize(browser); end
  def length; end
  def run; end
  def size; end
  def without; end
  include Enumerable
end
class Watir::Logger
  def create_logger(output); end
  def debug(*args, &block); end
  def debug?(*args, &block); end
  def deprecate(old, new, reference: nil, ids: nil); end
  def error(*args, &block); end
  def error?(*args, &block); end
  def fatal(*args, &block); end
  def fatal?(*args, &block); end
  def ignore(ids); end
  def info(*args, &block); end
  def info?(*args, &block); end
  def initialize(progname = nil); end
  def io; end
  def level(*args, &block); end
  def level=(*args, &block); end
  def output=(io); end
  def selenium=(val); end
  def warn(message, ids: nil, &block); end
  def warn?(*args, &block); end
  extend Forwardable
  include Logger::Severity
end
module Watir::Locators
end
class Watir::Locators::Element
end
class Watir::Locators::Element::Locator
  def driver_scope; end
  def element_matcher; end
  def initialize(element_matcher); end
  def locate(built); end
  def locate_all(built); end
  def locate_element(how, what, scope = nil); end
  def locate_elements(how, what, scope = nil); end
  def locator_scope; end
  def match_values; end
  def matching_elements; end
  def wd_locator; end
  include Watir::Exception
end
class Watir::Locators::Element::SelectorBuilder
  def build(selector); end
  def build_wd_selector(selector); end
  def built; end
  def check_custom_attribute(attribute); end
  def check_type(how, what); end
  def combine_with_xpath_or_css?(selector); end
  def custom_attributes; end
  def deprecate_class_array(class_array); end
  def deprecated_locators; end
  def implementation_class; end
  def initialize(valid_attributes, query_scope); end
  def merge_scope?; end
  def normalize_locator(how, what); end
  def normalize_selector; end
  def raise_unless(what, types); end
  def should_use_label_element?; end
  def valid_attribute?(attribute); end
  def wd_locator; end
  def wd_locators; end
  include Watir::Exception
end
module Watir::Locators::Element::SelectorBuilder::XpathSupport
  def self.downcase(value); end
  def self.escape(value); end
end
class Watir::Locators::Element::SelectorBuilder::RegexpDisassembler
  def extract_strings(expression, strings); end
  def fixed_repeat?(exp); end
  def initialize(regexp); end
  def min_repeat(exp); end
  def optional?(exp); end
  def substrings; end
end
class Watir::Locators::Element::SelectorBuilder::XPath
  def add_index(xpath, index); end
  def add_to_matching(key, regexp, results = nil); end
  def additional_string; end
  def adjacent_string; end
  def attribute_absence(attribute); end
  def attribute_presence(attribute); end
  def attribute_string; end
  def build(selector); end
  def build_valid_attributes; end
  def case_insensitive_attribute?(attribute); end
  def class_string; end
  def equal_pair(key, value); end
  def label_element_string; end
  def lhs_for(key, downcase: nil); end
  def predicate_conversion(key, regexp); end
  def predicate_expression(key, val); end
  def process_attribute(key, value); end
  def process_string(name); end
  def requires_matching?(results, regexp); end
  def start_string; end
  def starts_with?(results, regexp); end
  def tag_string; end
  def text_string; end
  def visible?; end
  include Watir::Exception
  include Watir::Locators::Element::SelectorBuilder::XpathSupport
end
class Watir::Locators::Element::Matcher
  def deprecate_text_regexp(element, selector); end
  def element_index(elements, values_to_match); end
  def elements_match?(element, values_to_match); end
  def fetch_value(element, how); end
  def initialize(query_scope, selector = nil); end
  def label_collection(elements, locator); end
  def match(elements, values_to_match, filter); end
  def matches_values?(found, expected); end
  def matching_elements(elements, values_to_match, filter: nil); end
  def matching_labels(elements, values_to_match); end
  def query_scope; end
  def selector; end
  def validate_tag(element, expected); end
  include Watir::Exception
end
class Watir::Locators::Anchor
end
class Watir::Locators::Anchor::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
  def build_link_text(selector); end
  def build_partial_link_text(selector); end
  def build_wd_selector(selector); end
  def can_convert_to_link_text?(selector); end
  def convert_to_partial_link_text?(selector); end
end
class Watir::Locators::Button
end
class Watir::Locators::Button::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
end
class Watir::Locators::Button::SelectorBuilder::XPath < Watir::Locators::Element::SelectorBuilder::XPath
  def button_string(text: nil, type: nil); end
  def input_string(text: nil, type: nil); end
  def input_types(type = nil); end
  def predicate_conversion(key, regexp); end
  def tag_string; end
  def text_string; end
end
class Watir::Locators::Button::Matcher < Watir::Locators::Element::Matcher
  def deprecate_value_button; end
  def elements_match?(element, values_to_match); end
  def validate_tag(element, _expected); end
end
class Watir::Locators::Cell
end
class Watir::Locators::Cell::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
  def merge_scope?; end
end
class Watir::Locators::Cell::SelectorBuilder::XPath < Watir::Locators::Element::SelectorBuilder::XPath
  def start_string; end
  def tag_string; end
end
class Watir::Locators::Row
end
class Watir::Locators::Row::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
  def build_wd_selector(selector); end
  def merge_scope?; end
end
class Watir::Locators::Row::SelectorBuilder::XPath < Watir::Locators::Element::SelectorBuilder::XPath
  def build(selector, scope_tag_name); end
  def generate_expressions(scope_tag_name); end
  def start_string; end
  def text_string; end
end
class Watir::Locators::TextArea
end
class Watir::Locators::TextArea::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
end
class Watir::Locators::TextArea::SelectorBuilder::XPath < Watir::Locators::Element::SelectorBuilder::XPath
  def process_attribute(key, value); end
end
class Watir::Locators::TextField
end
class Watir::Locators::TextField::SelectorBuilder < Watir::Locators::Element::SelectorBuilder
end
class Watir::Locators::TextField::SelectorBuilder::XPath < Watir::Locators::Element::SelectorBuilder::XPath
  def additional_string; end
  def negative_type_text; end
  def tag_string; end
  def text_string; end
  def type_string(type); end
end
class Watir::Locators::TextField::Matcher < Watir::Locators::Element::Matcher
  def elements_match?(element, values_to_match); end
  def text_regexp_deprecation(*arg0); end
  def validate_tag(element, _expected); end
end
module Watir::Locators::ClassHelpers
  def class_from_string(string); end
  def element_class_name; end
  def element_matcher_class; end
  def locator; end
  def locator_class; end
  def selector_builder; end
  def selector_builder_class; end
end
module Watir::AttributeHelper
  def attribute(type, method, attr); end
  def attribute_list; end
  def attributes; end
  def define_attribute(type, name, attr); end
  def define_boolean_attribute(mname, aname); end
  def define_float_attribute(mname, aname); end
  def define_int_attribute(mname, aname); end
  def define_string_attribute(mname, aname); end
  def inherit_attributes_from(kls); end
  def self.extended(klass); end
  def typed_attributes; end
end
module Watir::RowContainer
  def row(*args); end
  def rows(*args); end
  def strings; end
  def to_a; end
end
module Watir::CellContainer
  def cell(*args); end
  def cells(*args); end
end
module Watir::UserEditable
  def <<(*args); end
  def append(*args); end
  def clear; end
  def content_editable; end
  def content_editable_set!(*args); end
  def set!(*args); end
  def set(*args); end
  def value=(*args); end
end
class Watir::ElementCollection
  def ==(other); end
  def [](value); end
  def browser; end
  def build; end
  def construct_subtype(element, hash, tag_name); end
  def each(&blk); end
  def element_class; end
  def elements; end
  def elements_with_tags; end
  def empty?(*arg0); end
  def ensure_context; end
  def eql?(other); end
  def exist?(*arg0); end
  def exists?(*arg0); end
  def first; end
  def initialize(query_scope, selector); end
  def last; end
  def length(*arg0); end
  def locate; end
  def locate_all; end
  def reset!; end
  def size(*arg0); end
  def to_a; end
  include Enumerable
  include Watir::Exception
  include Watir::JSSnippets
  include Watir::Locators::ClassHelpers
  include Watir::Waitable
end
class Watir::Element
  def ==(other); end
  def assert_enabled; end
  def assert_exists; end
  def assert_is_element(obj); end
  def attribute(attribute_name); end
  def attribute_list; end
  def attribute_value(attribute_name); end
  def attribute_values; end
  def attributes; end
  def browser; end
  def build; end
  def cache=(element); end
  def center; end
  def centre; end
  def check_condition(condition, caller); end
  def class_name; end
  def classes; end
  def click!; end
  def click(*modifiers); end
  def display_check; end
  def double_click!; end
  def double_click; end
  def drag_and_drop_by(right_by, down_by); end
  def drag_and_drop_on(other); end
  def driver; end
  def element_call(precondition = nil, &block); end
  def element_class; end
  def enabled?; end
  def ensure_context; end
  def eql?(other); end
  def exist?; end
  def exists?; end
  def focused?; end
  def hash; end
  def height; end
  def hover; end
  def id; end
  def initialize(query_scope, selector); end
  def inspect; end
  def keyword; end
  def keyword=(arg0); end
  def locate; end
  def locate_in_context; end
  def located?; end
  def location; end
  def method_missing(meth, *args, &blk); end
  def obscured?; end
  def present?; end
  def raise_disabled; end
  def raise_present; end
  def raise_writable; end
  def reset!; end
  def respond_to_missing?(meth, *arg1); end
  def right_click(*modifiers); end
  def scroll_into_view; end
  def selector; end
  def selector_string; end
  def send_keys(*args); end
  def size; end
  def stale?; end
  def stale_in_context?; end
  def style(property = nil); end
  def tag_name; end
  def text; end
  def to_subtype; end
  def unknown_exception; end
  def visible?; end
  def wait_for_enabled; end
  def wait_for_exists; end
  def wait_for_present; end
  def wait_for_writable; end
  def wd; end
  def width; end
  extend Watir::AttributeHelper
  include Watir::Adjacent
  include Watir::Container
  include Watir::EventuallyPresent
  include Watir::Exception
  include Watir::JSExecution
  include Watir::Locators::ClassHelpers
  include Watir::Scrolling
  include Watir::Waitable
end
class Watir::HTMLElement < Watir::Element
  def accesskey; end
  def content_editable; end
  def content_editable?; end
  def dataset; end
  def dir; end
  def draggable?; end
  def hidden?; end
  def innertext; end
  def lang; end
  def onabort; end
  def onblur; end
  def oncancel; end
  def oncanplay; end
  def oncanplaythrough; end
  def onchange; end
  def onclick; end
  def onclose; end
  def oncopy; end
  def oncuechange; end
  def oncut; end
  def ondblclick; end
  def ondrag; end
  def ondragend; end
  def ondragenter; end
  def ondragexit; end
  def ondragleave; end
  def ondragover; end
  def ondragstart; end
  def ondrop; end
  def ondurationchange; end
  def onemptied; end
  def onended; end
  def onerror; end
  def onfocus; end
  def oninput; end
  def oninvalid; end
  def onkeydown; end
  def onkeypress; end
  def onkeyup; end
  def onload; end
  def onloadeddata; end
  def onloadedmetadata; end
  def onloadstart; end
  def onmousedown; end
  def onmouseenter; end
  def onmouseleave; end
  def onmousemove; end
  def onmouseout; end
  def onmouseover; end
  def onmouseup; end
  def onpaste; end
  def onpause; end
  def onplay; end
  def onplaying; end
  def onprogress; end
  def onratechange; end
  def onreset; end
  def onresize; end
  def onscroll; end
  def onseeked; end
  def onseeking; end
  def onselect; end
  def onshow; end
  def onstalled; end
  def onsubmit; end
  def onsuspend; end
  def ontimeupdate; end
  def ontoggle; end
  def onvolumechange; end
  def onwaiting; end
  def onwheel; end
  def spellcheck?; end
  def tabindex; end
  def title; end
  def translate?; end
end
class Watir::HTMLElementCollection < Watir::ElementCollection
end
class Watir::Font < Watir::HTMLElement
  def color; end
  def face; end
  def size; end
end
class Watir::FontCollection < Watir::ElementCollection
end
class Watir::Directory < Watir::HTMLElement
  def compact?; end
end
class Watir::DirectoryCollection < Watir::ElementCollection
end
class Watir::FrameSet < Watir::HTMLElement
  def cols; end
  def onafterprint; end
  def onbeforeprint; end
  def onbeforeunload; end
  def onhashchange; end
  def onlanguagechange; end
  def onmessage; end
  def onoffline; end
  def ononline; end
  def onpagehide; end
  def onpageshow; end
  def onpopstate; end
  def onrejectionhandled; end
  def onstorage; end
  def onunhandledrejection; end
  def onunload; end
end
class Watir::FrameSetCollection < Watir::ElementCollection
end
class Watir::Marquee < Watir::HTMLElement
  def behavior; end
  def bgcolor; end
  def direction; end
  def hspace; end
  def loop; end
  def onbounce; end
  def onfinish; end
  def onstart; end
  def scrollamount; end
  def scrolldelay; end
  def truespeed?; end
  def vspace; end
end
class Watir::MarqueeCollection < Watir::ElementCollection
end
class Watir::Applet < Watir::HTMLElement
  def align; end
  def alt; end
  def archive; end
  def code; end
  def codebase; end
  def hspace; end
  def name; end
  def object; end
  def vspace; end
end
class Watir::AppletCollection < Watir::ElementCollection
end
class Watir::Canvas < Watir::HTMLElement
end
class Watir::CanvasCollection < Watir::ElementCollection
end
class Watir::Template < Watir::HTMLElement
  def content; end
end
class Watir::TemplateCollection < Watir::ElementCollection
end
class Watir::Script < Watir::HTMLElement
  def async?; end
  def charset; end
  def crossorigin; end
  def defer?; end
  def event; end
  def for; end
  def nonce; end
  def src; end
  def type; end
end
class Watir::ScriptCollection < Watir::ElementCollection
end
class Watir::Dialog < Watir::HTMLElement
  def open?; end
  def returnvalue; end
end
class Watir::DialogCollection < Watir::ElementCollection
end
class Watir::Details < Watir::HTMLElement
  def open?; end
end
class Watir::DetailsCollection < Watir::ElementCollection
end
class Watir::Legend < Watir::HTMLElement
  def align; end
  def form; end
end
class Watir::LegendCollection < Watir::ElementCollection
end
class Watir::FieldSet < Watir::HTMLElement
  def disabled?; end
  def form; end
  def name; end
  def type; end
  def validationmessage; end
  def validity; end
  def willvalidate?; end
end
class Watir::FieldSetCollection < Watir::ElementCollection
end
class Watir::Meter < Watir::HTMLElement
  def high; end
  def labels; end
  def low; end
  def max; end
  def min; end
  def optimum; end
  def value; end
end
class Watir::MeterCollection < Watir::ElementCollection
end
class Watir::Progress < Watir::HTMLElement
  def labels; end
  def max; end
  def position; end
  def value; end
end
class Watir::ProgressCollection < Watir::ElementCollection
end
class Watir::Output < Watir::HTMLElement
  def defaultvalue; end
  def for; end
  def form; end
  def labels; end
  def name; end
  def type; end
  def validationmessage; end
  def validity; end
  def value; end
  def willvalidate?; end
end
class Watir::OutputCollection < Watir::ElementCollection
end
class Watir::TextArea < Watir::HTMLElement
  def autocomplete; end
  def autofocus?; end
  def cols; end
  def defaultvalue; end
  def dirname; end
  def disabled?; end
  def form; end
  def labels; end
  def maxlength; end
  def minlength; end
  def name; end
  def placeholder; end
  def readonly?; end
  def required?; end
  def selectiondirection; end
  def selectionend; end
  def selectionstart; end
  def textlength; end
  def type; end
  def validationmessage; end
  def validity; end
  def value; end
  def willvalidate?; end
  def wrap; end
  include Watir::UserEditable
end
class Watir::TextAreaCollection < Watir::ElementCollection
end
class Watir::Option < Watir::HTMLElement
  def clear; end
  def defaultselected?; end
  def disabled?; end
  def form; end
  def index; end
  def label; end
  def select(*modifiers); end
  def selected?; end
  def text; end
  def toggle(*modifiers); end
  def value; end
end
class Watir::OptionCollection < Watir::ElementCollection
end
class Watir::OptGroup < Watir::HTMLElement
  def disabled?; end
  def label; end
end
class Watir::OptGroupCollection < Watir::ElementCollection
end
class Watir::DataList < Watir::HTMLElement
end
class Watir::DataListCollection < Watir::ElementCollection
end
class Watir::Select < Watir::HTMLElement
  def autocomplete; end
  def autofocus?; end
  def clear; end
  def disabled?; end
  def find_options(how, str_or_rx); end
  def form; end
  def include?(str_or_rx); end
  def labels; end
  def length; end
  def matching_option?(how, what); end
  def multiple?; end
  def name; end
  def process_str_or_rx(str_or_rx); end
  def raise_no_value_found(str_or_rx); end
  def required?; end
  def select!(*str_or_rx); end
  def select(*str_or_rx); end
  def select_all!(*str_or_rx); end
  def select_all(*str_or_rx); end
  def select_all_by(str_or_rx); end
  def select_by!(str_or_rx, number); end
  def select_by(str_or_rx); end
  def select_matching(elements); end
  def select_value(str_or_rx); end
  def selected?(str_or_rx); end
  def selected_options; end
  def selectedindex; end
  def selectedoptions; end
  def text; end
  def type; end
  def validationmessage; end
  def validity; end
  def value; end
  def willvalidate?; end
end
class Watir::SelectCollection < Watir::ElementCollection
end
class Watir::Button < Watir::HTMLElement
  def accept; end
  def align; end
  def alt; end
  def autocomplete; end
  def autofocus?; end
  def checked?; end
  def defaultchecked?; end
  def defaultvalue; end
  def dirname; end
  def disabled?; end
  def files; end
  def form; end
  def formaction; end
  def formenctype; end
  def formmethod; end
  def formnovalidate?; end
  def formtarget; end
  def indeterminate?; end
  def labels; end
  def list; end
  def max; end
  def maxlength; end
  def min; end
  def minlength; end
  def multiple?; end
  def name; end
  def placeholder; end
  def readonly?; end
  def required?; end
  def selectiondirection; end
  def selectionend; end
  def selectionstart; end
  def src; end
  def step; end
  def text; end
  def type; end
  def usemap; end
  def validationmessage; end
  def validity; end
  def value; end
  def valueasdate; end
  def valueasnumber; end
  def willvalidate?; end
end
class Watir::ButtonCollection < Watir::ElementCollection
end
class Watir::Input < Watir::HTMLElement
  def accept; end
  def align; end
  def alt; end
  def autocomplete; end
  def autofocus?; end
  def checked?; end
  def defaultchecked?; end
  def defaultvalue; end
  def dirname; end
  def disabled?; end
  def files; end
  def form; end
  def formaction; end
  def formenctype; end
  def formmethod; end
  def formnovalidate?; end
  def formtarget; end
  def indeterminate?; end
  def label; end
  def labels; end
  def list; end
  def max; end
  def maxlength; end
  def min; end
  def minlength; end
  def multiple?; end
  def name; end
  def pattern; end
  def placeholder; end
  def readonly?; end
  def required?; end
  def selectiondirection; end
  def selectionend; end
  def selectionstart; end
  def src; end
  def step; end
  def type; end
  def usemap; end
  def validationmessage; end
  def validity; end
  def value; end
  def valueasdate; end
  def valueasnumber; end
  def willvalidate?; end
end
class Watir::InputCollection < Watir::ElementCollection
end
class Watir::Label < Watir::HTMLElement
  def control; end
  def for; end
  def form; end
end
class Watir::LabelCollection < Watir::ElementCollection
end
class Watir::Form < Watir::HTMLElement
  def accept_charset; end
  def action; end
  def autocomplete; end
  def encoding; end
  def enctype; end
  def length; end
  def name; end
  def novalidate?; end
  def submit; end
  def target; end
end
class Watir::FormCollection < Watir::ElementCollection
end
class Watir::TableCell < Watir::HTMLElement
  def align; end
  def axis; end
  def bgcolor; end
  def cellindex; end
  def ch; end
  def choff; end
  def colspan; end
  def column_header; end
  def header_row(current_row, opt); end
  def headers; end
  def nowrap?; end
  def rowspan; end
  def sibling_from_header(opt); end
  def valign; end
end
class Watir::TableCellCollection < Watir::ElementCollection
end
class Watir::TableHeaderCell < Watir::TableCell
  def abbr; end
  def scope; end
end
class Watir::TableHeaderCellCollection < Watir::ElementCollection
end
class Watir::TableDataCell < Watir::TableCell
end
class Watir::TableDataCellCollection < Watir::ElementCollection
end
class Watir::TableRow < Watir::HTMLElement
  def [](idx); end
  def align; end
  def bgcolor; end
  def ch; end
  def choff; end
  def each(&block); end
  def rowindex; end
  def sectionrowindex; end
  def valign; end
  include Enumerable
  include Watir::CellContainer
end
class Watir::TableRowCollection < Watir::ElementCollection
end
class Watir::TableSection < Watir::HTMLElement
  def [](idx); end
  def align; end
  def ch; end
  def choff; end
  def valign; end
  include Watir::RowContainer
end
class Watir::TableSectionCollection < Watir::ElementCollection
end
class Watir::TableCol < Watir::HTMLElement
  def align; end
  def ch; end
  def choff; end
  def valign; end
end
class Watir::TableColCollection < Watir::ElementCollection
end
class Watir::TableCaption < Watir::HTMLElement
  def align; end
end
class Watir::TableCaptionCollection < Watir::ElementCollection
end
class Watir::Table < Watir::HTMLElement
  def [](idx); end
  def align; end
  def bgcolor; end
  def border; end
  def caption; end
  def cell_size_check(header_row, cell_row); end
  def cellpadding; end
  def cellspacing; end
  def each(&block); end
  def frame; end
  def hashes; end
  def headers(row = nil); end
  def rules; end
  def summary; end
  def tbodies; end
  include Enumerable
  include Watir::RowContainer
end
class Watir::TableCollection < Watir::ElementCollection
end
class Watir::Area < Watir::HTMLElement
  def alt; end
  def coords; end
  def download; end
  def host; end
  def hostname; end
  def href; end
  def hreflang; end
  def nohref?; end
  def origin; end
  def password; end
  def pathname; end
  def port; end
  def protocol; end
  def referrerpolicy; end
  def rel; end
  def rellist; end
  def search; end
  def shape; end
  def target; end
  def type; end
  def username; end
end
class Watir::AreaCollection < Watir::ElementCollection
end
class Watir::Map < Watir::HTMLElement
  def areas; end
  def images; end
  def name; end
end
class Watir::MapCollection < Watir::ElementCollection
end
class Watir::Media < Watir::HTMLElement
  def audiotracks; end
  def autoplay?; end
  def buffered; end
  def controls?; end
  def crossorigin; end
  def currentsrc; end
  def currenttime; end
  def defaultmuted?; end
  def defaultplaybackrate; end
  def duration; end
  def ended?; end
  def error; end
  def loop?; end
  def muted?; end
  def networkstate; end
  def paused?; end
  def playbackrate; end
  def played; end
  def preload; end
  def readystate; end
  def seekable; end
  def seeking?; end
  def src; end
  def srcobject; end
  def texttracks; end
  def videotracks; end
  def volume; end
end
class Watir::MediaCollection < Watir::ElementCollection
end
class Watir::Audio < Watir::Media
end
class Watir::AudioCollection < Watir::ElementCollection
end
class Watir::Video < Watir::Media
  def poster; end
  def videoheight; end
  def videowidth; end
end
class Watir::VideoCollection < Watir::ElementCollection
end
class Watir::Track < Watir::HTMLElement
  def default?; end
  def kind; end
  def label; end
  def readystate; end
  def src; end
  def srclang; end
  def track; end
end
class Watir::TrackCollection < Watir::ElementCollection
end
class Watir::Param < Watir::HTMLElement
  def name; end
  def type; end
  def value; end
  def valuetype; end
end
class Watir::ParamCollection < Watir::ElementCollection
end
class Watir::Object < Watir::HTMLElement
  def align; end
  def archive; end
  def border; end
  def code; end
  def codebase; end
  def codetype; end
  def contentdocument; end
  def contentwindow; end
  def data; end
  def declare?; end
  def form; end
  def hspace; end
  def name; end
  def standby; end
  def type; end
  def typemustmatch?; end
  def validationmessage; end
  def validity; end
  def vspace; end
  def willvalidate?; end
end
class Watir::ObjectCollection < Watir::ElementCollection
end
class Watir::Embed < Watir::HTMLElement
  def align; end
  def name; end
  def src; end
  def type; end
end
class Watir::EmbedCollection < Watir::ElementCollection
end
class Watir::IFrame < Watir::HTMLElement
  def align; end
  def allowfullscreen?; end
  def allowpaymentrequest?; end
  def contentdocument; end
  def contentwindow; end
  def execute_script(script, *args, function_name: nil); end
  def frameborder; end
  def html; end
  def longdesc; end
  def marginheight; end
  def marginwidth; end
  def name; end
  def referrerpolicy; end
  def sandbox; end
  def scrolling; end
  def send_keys(*args); end
  def src; end
  def srcdoc; end
  def switch_to!; end
  def text; end
  def to_subtype; end
  def unknown_exception; end
  def wd; end
end
class Watir::IFrameCollection < Watir::ElementCollection
end
class Watir::Image < Watir::HTMLElement
  def align; end
  def alt; end
  def border; end
  def complete?; end
  def crossorigin; end
  def currentsrc; end
  def hspace; end
  def ismap?; end
  def loaded?; end
  def longdesc; end
  def lowsrc; end
  def name; end
  def naturalheight; end
  def naturalwidth; end
  def referrerpolicy; end
  def sizes; end
  def src; end
  def srcset; end
  def usemap; end
  def vspace; end
end
class Watir::ImageCollection < Watir::ElementCollection
end
class Watir::Source < Watir::HTMLElement
  def media; end
  def sizes; end
  def src; end
  def srcset; end
  def type; end
end
class Watir::SourceCollection < Watir::ElementCollection
end
class Watir::Picture < Watir::HTMLElement
end
class Watir::PictureCollection < Watir::ElementCollection
end
class Watir::Mod < Watir::HTMLElement
  def cite; end
  def datetime; end
end
class Watir::ModCollection < Watir::ElementCollection
end
class Watir::BR < Watir::HTMLElement
  def clear; end
end
class Watir::BRCollection < Watir::ElementCollection
end
class Watir::Span < Watir::HTMLElement
end
class Watir::SpanCollection < Watir::ElementCollection
end
class Watir::Time < Watir::HTMLElement
  def datetime; end
end
class Watir::TimeCollection < Watir::ElementCollection
end
class Watir::Data < Watir::HTMLElement
  def value; end
end
class Watir::DataCollection < Watir::ElementCollection
end
class Watir::Anchor < Watir::HTMLElement
  def charset; end
  def coords; end
  def download; end
  def host; end
  def hostname; end
  def href; end
  def hreflang; end
  def name; end
  def origin; end
  def password; end
  def pathname; end
  def port; end
  def protocol; end
  def referrerpolicy; end
  def rel; end
  def rellist; end
  def rev; end
  def search; end
  def shape; end
  def target; end
  def type; end
  def username; end
end
class Watir::AnchorCollection < Watir::ElementCollection
end
class Watir::Div < Watir::HTMLElement
  def align; end
end
class Watir::DivCollection < Watir::ElementCollection
end
class Watir::DList < Watir::HTMLElement
  def compact?; end
  def to_hash; end
end
class Watir::DListCollection < Watir::ElementCollection
end
class Watir::LI < Watir::HTMLElement
  def type; end
  def value; end
end
class Watir::LICollection < Watir::ElementCollection
end
class Watir::UList < Watir::HTMLElement
  def compact?; end
  def type; end
  include Watir::List
end
class Watir::UListCollection < Watir::ElementCollection
end
class Watir::OList < Watir::HTMLElement
  def compact?; end
  def reversed?; end
  def start; end
  def type; end
  include Watir::List
end
class Watir::OListCollection < Watir::ElementCollection
end
class Watir::Quote < Watir::HTMLElement
  def cite; end
end
class Watir::QuoteCollection < Watir::ElementCollection
end
class Watir::Pre < Watir::HTMLElement
end
class Watir::PreCollection < Watir::ElementCollection
end
class Watir::HR < Watir::HTMLElement
  def align; end
  def color; end
  def noshade?; end
end
class Watir::HRCollection < Watir::ElementCollection
end
class Watir::Paragraph < Watir::HTMLElement
  def align; end
end
class Watir::ParagraphCollection < Watir::ElementCollection
end
class Watir::Heading < Watir::HTMLElement
  def align; end
end
class Watir::HeadingCollection < Watir::ElementCollection
end
class Watir::Body < Watir::HTMLElement
  def alink; end
  def background; end
  def bgcolor; end
  def onafterprint; end
  def onbeforeprint; end
  def onbeforeunload; end
  def onhashchange; end
  def onlanguagechange; end
  def onmessage; end
  def onoffline; end
  def ononline; end
  def onpagehide; end
  def onpageshow; end
  def onpopstate; end
  def onrejectionhandled; end
  def onstorage; end
  def onunhandledrejection; end
  def onunload; end
  def vlink; end
end
class Watir::BodyCollection < Watir::ElementCollection
end
class Watir::Style < Watir::HTMLElement
  def media; end
  def nonce; end
  def type; end
end
class Watir::StyleCollection < Watir::ElementCollection
end
class Watir::Meta < Watir::HTMLElement
  def content; end
  def http_equiv; end
  def name; end
  def scheme; end
end
class Watir::MetaCollection < Watir::ElementCollection
end
class Watir::Base < Watir::HTMLElement
  def href; end
  def target; end
end
class Watir::BaseCollection < Watir::ElementCollection
end
class Watir::Title < Watir::HTMLElement
end
class Watir::TitleCollection < Watir::ElementCollection
end
class Watir::Head < Watir::HTMLElement
end
class Watir::HeadCollection < Watir::ElementCollection
end
class Watir::Html < Watir::HTMLElement
  def version; end
end
class Watir::HtmlCollection < Watir::ElementCollection
end
class Watir::Unknown < Watir::HTMLElement
end
class Watir::UnknownCollection < Watir::ElementCollection
end
class Watir::SVGElement < Watir::HTMLElement
  def classname; end
  def correspondingelement; end
  def correspondinguseelement; end
  def ownersvgelement; end
  def viewportelement; end
end
class Watir::SVGElementCollection < Watir::ElementCollection
end
class Watir::View < Watir::SVGElement
  def preserveaspectratio; end
  def viewbox; end
  def zoomandpan; end
end
class Watir::ViewCollection < Watir::ElementCollection
end
class Watir::Pattern < Watir::SVGElement
  def href; end
  def patterncontentunits; end
  def patterntransform; end
  def patternunits; end
  def preserveaspectratio; end
  def viewbox; end
  def x; end
  def y; end
end
class Watir::PatternCollection < Watir::ElementCollection
end
class Watir::Stop < Watir::SVGElement
  def offset; end
end
class Watir::StopCollection < Watir::ElementCollection
end
class Watir::Gradient < Watir::SVGElement
  def gradienttransform; end
  def gradientunits; end
  def href; end
  def spreadmethod; end
end
class Watir::GradientCollection < Watir::ElementCollection
end
class Watir::RadialGradient < Watir::Gradient
  def cx; end
  def cy; end
  def fr; end
  def fx; end
  def fy; end
  def r; end
end
class Watir::RadialGradientCollection < Watir::ElementCollection
end
class Watir::LinearGradient < Watir::Gradient
  def x1; end
  def x2; end
  def y1; end
  def y2; end
end
class Watir::LinearGradientCollection < Watir::ElementCollection
end
class Watir::Marker < Watir::SVGElement
  def markerheight; end
  def markerunits; end
  def markerwidth; end
  def orient; end
  def orientangle; end
  def orienttype; end
  def preserveaspectratio; end
  def refx; end
  def refy; end
  def viewbox; end
end
class Watir::MarkerCollection < Watir::ElementCollection
end
class Watir::Metadata < Watir::SVGElement
end
class Watir::MetadataCollection < Watir::ElementCollection
end
class Watir::Desc < Watir::SVGElement
end
class Watir::DescCollection < Watir::ElementCollection
end
class Watir::Graphics < Watir::SVGElement
  def requiredextensions; end
  def systemlanguage; end
  def transform; end
end
class Watir::GraphicsCollection < Watir::ElementCollection
end
class Watir::ForeignObject < Watir::Graphics
  def x; end
  def y; end
end
class Watir::ForeignObjectCollection < Watir::ElementCollection
end
class Watir::TextContent < Watir::Graphics
  def lengthadjust; end
  def textlength; end
end
class Watir::TextContentCollection < Watir::ElementCollection
end
class Watir::TextPath < Watir::TextContent
  def href; end
  def spacing; end
  def startoffset; end
end
class Watir::TextPathCollection < Watir::ElementCollection
end
class Watir::TextPositioning < Watir::TextContent
  def dx; end
  def dy; end
  def rotate; end
  def x; end
  def y; end
end
class Watir::TextPositioningCollection < Watir::ElementCollection
end
class Watir::TSpan < Watir::TextPositioning
end
class Watir::TSpanCollection < Watir::ElementCollection
end
class Watir::Switch < Watir::Graphics
end
class Watir::SwitchCollection < Watir::ElementCollection
end
class Watir::Use < Watir::Graphics
  def animatedinstanceroot; end
  def href; end
  def instanceroot; end
  def x; end
  def y; end
end
class Watir::UseCollection < Watir::ElementCollection
end
class Watir::Symbol < Watir::Graphics
  def preserveaspectratio; end
  def viewbox; end
end
class Watir::SymbolCollection < Watir::ElementCollection
end
class Watir::Defs < Watir::Graphics
end
class Watir::DefsCollection < Watir::ElementCollection
end
class Watir::G < Watir::Graphics
end
class Watir::GCollection < Watir::ElementCollection
end
class Watir::SVG < Watir::Graphics
  def currentscale; end
  def currenttranslate; end
  def preserveaspectratio; end
  def viewbox; end
  def x; end
  def y; end
  def zoomandpan; end
end
class Watir::SVGCollection < Watir::ElementCollection
end
class Watir::Geometry < Watir::Graphics
  def pathlength; end
end
class Watir::GeometryCollection < Watir::ElementCollection
end
class Watir::Polygon < Watir::Geometry
  def animatedpoints; end
  def points; end
end
class Watir::PolygonCollection < Watir::ElementCollection
end
class Watir::Polyline < Watir::Geometry
  def animatedpoints; end
  def points; end
end
class Watir::PolylineCollection < Watir::ElementCollection
end
class Watir::Line < Watir::Geometry
  def x1; end
  def x2; end
  def y1; end
  def y2; end
end
class Watir::LineCollection < Watir::ElementCollection
end
class Watir::Ellipse < Watir::Geometry
  def cx; end
  def cy; end
  def rx; end
  def ry; end
end
class Watir::EllipseCollection < Watir::ElementCollection
end
class Watir::Circle < Watir::Geometry
  def cx; end
  def cy; end
  def r; end
end
class Watir::CircleCollection < Watir::ElementCollection
end
class Watir::Rect < Watir::Geometry
  def rx; end
  def ry; end
  def x; end
  def y; end
end
class Watir::RectCollection < Watir::ElementCollection
end
class Watir::Path < Watir::Geometry
end
class Watir::PathCollection < Watir::ElementCollection
end
class Watir::Cell < Watir::TableCell
end
class Watir::CellCollection < Watir::TableCellCollection
  def elements; end
end
class Watir::CheckBox < Watir::Input
  def check(bool = nil); end
  def checked?; end
  def clear; end
  def set(bool = nil); end
  def set?; end
  def uncheck; end
end
class Watir::CheckBoxCollection < Watir::InputCollection
end
class Watir::DateField < Watir::Input
  def set!(date); end
  def set(date); end
  def value=(date); end
end
class Watir::DateFieldCollection < Watir::InputCollection
  def element_class; end
end
class Watir::DateTimeField < Watir::Input
  def set!(date); end
  def set(date); end
  def value=(date); end
end
class Watir::DateTimeFieldCollection < Watir::InputCollection
  def element_class; end
end
class Watir::FileField < Watir::Input
  def set(path); end
  def upload(path); end
  def value=(path); end
end
class Watir::FileFieldCollection < Watir::InputCollection
end
class Watir::Frame < Watir::IFrame
end
class Watir::FrameCollection < Watir::IFrameCollection
end
class Watir::FramedDriver
  def ==(other); end
  def eql?(other); end
  def initialize(element, browser); end
  def method_missing(meth, *args, &blk); end
  def respond_to_missing?(meth, _include_private); end
  def send_keys(*args); end
  def switch!; end
  def wd; end
  include Watir::Exception
end
class Watir::Hidden < Watir::Input
  def click; end
  def visible?; end
end
class Watir::HiddenCollection < Watir::InputCollection
end
module Watir::List
  def [](idx); end
  def each(&block); end
  def empty?(*arg0); end
  def items(*arg0); end
  def length(*arg0); end
  def list_items; end
  def size(*arg0); end
  include Enumerable
end
class Watir::Radio < Watir::Input
  def build; end
  def select; end
  def selected?; end
  def set; end
  def set?; end
  def text; end
end
class Watir::RadioCollection < Watir::InputCollection
  def build; end
  def element_class; end
end
class Watir::Row < Watir::TableRow
end
class Watir::RowCollection < Watir::TableRowCollection
  def to_a; end
end
class Watir::TextField < Watir::Input
  def selector_string; end
  include Watir::UserEditable
end
class Watir::TextFieldCollection < Watir::InputCollection
  def element_class; end
end
class Watir::RadioSet
  def ==(other); end
  def [](idx); end
  def assert_exists(*args, &blk); end
  def browser(*args, &block); end
  def disabled?; end
  def each(&block); end
  def element_call(*args, &blk); end
  def enabled?; end
  def eql?(other); end
  def exist?(*args, &block); end
  def exists?(*args, &block); end
  def frame; end
  def include?(str_or_rx); end
  def initialize(query_scope, selector); end
  def name; end
  def present?(*args, &block); end
  def radio(opt = nil); end
  def radios(opt = nil); end
  def select(str_or_rx); end
  def selected; end
  def selected?(str_or_rx); end
  def single_radio_collection; end
  def source; end
  def text; end
  def type; end
  def value; end
  def visible?(*args, &block); end
  extend Forwardable
  include Enumerable
  include Watir::Exception
end
